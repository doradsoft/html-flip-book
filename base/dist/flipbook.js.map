{"version":3,"file":"flipbook.js","sources":["../src/flip-direction.ts","../src/leaf.ts","../src/aspect-ratio.ts","../src/size.ts","../src/flipbook.ts"],"sourcesContent":["export enum FlipDirection {\n  Forward = 'Forward',\n  Backward = 'Backward',\n  None = 'None'\n}\n","import { throttle } from 'throttle-debounce'\nimport type { IntRange } from 'type-fest'\nimport { FlipDirection } from './flip-direction'\n\n// number between 1 to infinity\nexport type DegreesPerSecond = IntRange<1, typeof Infinity>\nexport type FlipPosition = IntRange<0, 2>\nexport const FLIPPED = true\nexport const NOT_FLIPPED = false\nexport class Leaf {\n  private currentAnimation: Promise<void> | null = null\n  private targetFlipPosition: FlipPosition | null = null\n  private wrappedFlipPosition: number\n\n  constructor(\n    readonly index: number,\n    readonly pages: [HTMLElement, HTMLElement | undefined],\n    isFlipped: boolean,\n    private readonly bookProperties: {\n      isLTR: boolean\n      pagesCount: number\n      leavesCount: number\n    },\n    private readonly onTurned: (direction: FlipDirection) => void\n  ) {\n    this.wrappedFlipPosition = isFlipped ? 1 : 0\n    // TODO: rethink this\n    // if(isFlipped) {\n    //   // this.flipToPosition(1);\n    // }\n  }\n\n  get isTurned(): boolean {\n    return this.flipPosition === 1\n  }\n  get isTurning(): boolean {\n    return this.flipPosition !== 0\n  }\n  get isCover(): boolean {\n    return this.isFirst || this.isLast\n  }\n  get isFirst(): boolean {\n    return this.index === 0\n  }\n  get isLast(): boolean {\n    return this.index === this.bookProperties.leavesCount - 1\n  }\n  set flipPosition(value: number) {\n    this.wrappedFlipPosition = Math.max(0, Math.min(1, value)) as FlipPosition\n  }\n  get flipPosition(): number {\n    return this.wrappedFlipPosition\n  }\n\n  async flipToPosition(\n    flipPosition: FlipPosition,\n    velocity: DegreesPerSecond = 225 as DegreesPerSecond\n  ) {\n    if (this.currentAnimation) {\n      await this.currentAnimation\n    }\n\n    if (this.flipPosition === flipPosition) {\n      return Promise.resolve()\n    }\n\n    if (this.targetFlipPosition === flipPosition) {\n      return this.currentAnimation ?? Promise.resolve()\n    }\n\n    this.targetFlipPosition = flipPosition\n\n    this.currentAnimation = new Promise<void>(resolve => {\n      const currentFlipPosition = this.flipPosition\n      const distance = Math.abs(flipPosition - currentFlipPosition)\n      const duration = ((distance * 180) / velocity) * 1000 // duration in milliseconds\n\n      const start = performance.now()\n      const step = (timestamp: number) => {\n        const elapsed = timestamp - start\n\n        if (elapsed < 0) {\n          requestAnimationFrame(step)\n          return\n        }\n\n        const progress = Math.min(elapsed / duration, 1)\n        const newPosition =\n          currentFlipPosition + progress * (flipPosition - currentFlipPosition)\n\n        this.pages.forEach((page, index) => {\n          const isLTR = this.bookProperties.isLTR\n          if (page) {\n            const isOdd = (index % 2) + 1 === 1\n            const degrees = isOdd\n              ? isLTR\n                ? newPosition > 0.5\n                  ? 180 - newPosition * 180\n                  : -newPosition * 180\n                : newPosition > 0.5\n                  ? -(180 - newPosition * 180)\n                  : newPosition * 180\n              : isLTR\n                ? newPosition < 0.5\n                  ? -newPosition * 180\n                  : 180 - newPosition * 180\n                : newPosition < 0.5\n                  ? newPosition * 180\n                  : -(180 - newPosition * 180)\n            const rotateY = `${degrees}deg`\n            const translateX = `${\n              isOdd ? (isLTR ? `100%` : `-100%`) : isLTR ? `0px` : `0px`\n            }`\n            const scaleX = isOdd\n              ? newPosition > 0.5\n                ? -1\n                : 1\n              : newPosition < 0.5\n                ? -1\n                : 1\n            page.style.transform = `translateX(${translateX})rotateY(${rotateY})scaleX(${scaleX})`\n            // console.log(page.style.transform);\n            page.style.transformOrigin = isOdd\n              ? `${isLTR ? 'left' : 'right'}`\n              : `${isLTR ? 'right' : 'left'}`\n            page.style.zIndex = `${\n              newPosition > 0.5\n                ? page.dataset.pageIndex\n                : this.bookProperties.pagesCount -\n                  (page.dataset.pageIndex as unknown as number)\n            }`\n          }\n        })\n\n        // Ensure the new position is within valid bounds [0, 1]\n        this.flipPosition = Math.max(\n          0,\n          Math.min(1, newPosition)\n        ) as FlipPosition\n        if (this.flipPosition === 1 || this.flipPosition === 0) {\n          this.onTurned(\n            this.flipPosition === 1\n              ? FlipDirection.Forward\n              : FlipDirection.Backward\n          )\n        }\n        // Detailed log for debugging\n        // console.log(\n        //   `Timestamp: ${timestamp}, Elapsed: ${elapsed}, Progress: ${progress}, Current Position: ${currentFlipPosition}, Requested Position: ${flipPosition}, New Position: ${this.flipPosition}`\n        // );\n\n        if (progress < 1) {\n          requestAnimationFrame(step)\n        } else {\n          this.currentAnimation = null\n          this.targetFlipPosition = null\n          resolve()\n        }\n      }\n\n      requestAnimationFrame(step)\n    })\n\n    return this.currentAnimation\n  }\n\n  async efficientFlipToPosition(\n    flipPosition: FlipPosition,\n    velocity: DegreesPerSecond = 20000 as DegreesPerSecond\n  ) {\n    return throttle(1, this.flipToPosition.bind(this))(flipPosition, velocity)\n  }\n}\n","export interface AspectRatio {\n  width: number\n  height: number\n}\nexport class AspectRatioImpl implements AspectRatio {\n  static from(aspectRatio: AspectRatio) {\n    return new AspectRatioImpl(aspectRatio.width, aspectRatio.height)\n  }\n  constructor(\n    public readonly width: number,\n    public readonly height: number\n  ) {}\n  get value(): number {\n    return this.width / this.height\n  }\n}\n","import { AspectRatio, AspectRatioImpl } from './aspect-ratio'\n\nexport class Size {\n  aspectRatio: AspectRatioImpl\n  aspectRatioFit(rhsAspectRatio: AspectRatio) {\n    const rhsAspectRatioValue = AspectRatioImpl.from(rhsAspectRatio).value\n    return this.aspectRatio.value > rhsAspectRatioValue\n      ? new Size(this.height * rhsAspectRatioValue, this.height)\n      : new Size(this.width, this.width / rhsAspectRatioValue)\n  }\n  constructor(\n    public readonly width: number,\n    public readonly height: number\n  ) {\n    this.aspectRatio = new AspectRatioImpl(width, height)\n  }\n  get asString(): string {\n    return `${this.width}x${this.height}`\n  }\n}\n","import './pages.scss'\nimport './flipbook.scss'\nimport type { PageSemantics } from './page-semantics'\nimport Hammer from 'hammerjs'\nimport { Leaf, NOT_FLIPPED, type FlipPosition } from './leaf'\nimport type { FlipBookOptions } from './flip-book-options'\nimport { FlipDirection } from './flip-direction'\nimport type { AspectRatio } from './aspect-ratio'\nimport { Size } from './size'\n\nconst FAST_DELTA = 500\nclass FlipBook {\n  bookElement?: HTMLElement\n  private pageElements: HTMLElement[] = []\n  private readonly pagesCount: number\n  private readonly leafAspectRatio: AspectRatio = { width: 2, height: 3 }\n  private readonly coverAspectRatio: AspectRatio = {\n    width: 2.15,\n    height: 3.15\n  }\n  private readonly direction: 'rtl' | 'ltr' = 'ltr'\n  private readonly onPageChanged?: (pageIndex: number) => void\n  private readonly pageSemantics: PageSemantics | undefined\n  private leaves: Leaf[] = []\n  // flipping state\n  private currentLeaf: Leaf | undefined = undefined\n  private flipDirection: FlipDirection = FlipDirection.None\n  private flipStartingPos = 0\n  private isDuringManualFlip = false\n  private flipDelta = 0\n  private isDuringAutoFlip = false\n  touchStartingPos = { x: 0, y: 0 }\n  private prevVisiblePageIndices: [number] | [number, number] | undefined\n  private get isLTR(): boolean {\n    return this.direction === 'ltr'\n  }\n  private get isClosed(): boolean {\n    return !this.currentOrTurningLeaves[0]\n  }\n  private get isClosedInverted(): boolean {\n    return !this.currentLeaves[1]\n  }\n  private get currentLeaves(): [Leaf | undefined, Leaf | undefined] {\n    let secondLeafIndex = -1\n    for (let i = this.leaves.length - 1; i >= 0; i--) {\n      const leaf = this.leaves[i]\n      if (leaf.isTurned) {\n        secondLeafIndex = leaf.index + 1\n        break\n      }\n    }\n    return secondLeafIndex == -1\n      ? [undefined, this.leaves[0]]\n      : secondLeafIndex == this.leaves.length\n        ? [this.leaves[secondLeafIndex - 1], undefined]\n        : [this.leaves[secondLeafIndex - 1], this.leaves[secondLeafIndex]]\n  }\n\n  private get currentOrTurningLeaves(): [Leaf | undefined, Leaf | undefined] {\n    let secondLeafIndex = -1\n    for (let i = this.leaves.length - 1; i >= 0; i--) {\n      const leaf = this.leaves[i]\n      if (leaf.isTurned || leaf.isTurning) {\n        secondLeafIndex = leaf.index + 1\n        break\n      }\n    }\n    return secondLeafIndex == -1\n      ? [undefined, this.leaves[0]]\n      : secondLeafIndex == this.leaves.length\n        ? [this.leaves[secondLeafIndex - 1], undefined]\n        : [this.leaves[secondLeafIndex - 1], this.leaves[secondLeafIndex]]\n  }\n\n  constructor(options: FlipBookOptions) {\n    this.pagesCount = options.pagesCount\n    this.leafAspectRatio = options.leafAspectRatio || this.leafAspectRatio\n    this.coverAspectRatio = options.coverAspectRatio || this.coverAspectRatio\n    this.direction = options.direction || this.direction\n    this.pageSemantics = options.pageSemantics\n    this.onPageChanged = options.onPageChanged\n  }\n\n  render(selector: string, debug = false) {\n    const bookElement = document.querySelector(selector)\n    if (!bookElement) {\n      throw new Error(`Couldn't find container with selector: ${selector}`)\n    }\n    this.bookElement = bookElement as HTMLElement\n    if (!this.bookElement.classList.contains('flipbook')) {\n      this.bookElement.classList.add('flipbook')\n    }\n\n    const pageElements = bookElement.querySelectorAll('.page')\n    if (!pageElements.length) {\n      throw new Error('No pages found in flipbook')\n    }\n    this.pageElements = Array.from(pageElements) as HTMLElement[]\n    this.leaves.splice(0, this.leaves.length)\n    const leavesCount = Math.ceil(this.pagesCount / 2)\n    const maxCoverSize = new Size(\n      this.bookElement.clientWidth / 2,\n      this.bookElement.clientHeight\n    )\n    const coverSize = maxCoverSize.aspectRatioFit(this.coverAspectRatio)\n    const leafSize = new Size(\n      (coverSize.width * this.leafAspectRatio.width) /\n        this.coverAspectRatio.width,\n      (coverSize.height * this.leafAspectRatio.height) /\n        this.coverAspectRatio.height\n    )\n    this.bookElement.style.perspective = `${\n      Math.min(leafSize.width * 2, leafSize.height) * 2\n    }px`\n    this.pageElements.forEach((pageElement, pageIndex) => {\n      pageElement.style.width = `${leafSize.width}px`\n      pageElement.style.height = `${leafSize.height}px`\n\n      pageElement.style.zIndex = `${this.pagesCount - pageIndex}`\n      pageElement.dataset.pageIndex = pageIndex.toString()\n      pageElement.style[this.isLTR ? 'left' : 'right'] = `${\n        (bookElement.clientWidth - 2 * leafSize.width) / 2\n      }px`\n      pageElement.style.top = `${\n        (bookElement.clientHeight - leafSize.height) / 2\n      }px`\n      pageElement.dataset.pageSemanticName =\n        this.pageSemantics?.indexToSemanticName(pageIndex) ?? ''\n      pageElement.dataset.pageTitle =\n        this.pageSemantics?.indexToTitle(pageIndex) ?? ''\n\n      const leafIndex = Math.floor(pageIndex / 2)\n      const isOddPage = (pageIndex + 1) % 2 === 1\n      // TODO: set dynamically by parameter and not by hardcoding eq 0\n      // TODO: set prev-page / next-page classes for prev/next pages as accordingally\n      pageElement.classList.add(\n        isOddPage ? 'odd' : 'even',\n        ...(pageIndex === 0 ? ['current-page'] : [])\n      )\n      if (isOddPage) {\n        pageElement.style.transform = `translateX(${this.isLTR ? `` : `-`}100%)`\n\n        this.leaves[leafIndex] = new Leaf(\n          leafIndex,\n          [pageElement, undefined],\n          // TODO: set turned based on initialized page\n          NOT_FLIPPED,\n          {\n            isLTR: this.isLTR,\n            leavesCount: leavesCount,\n            pagesCount: this.pagesCount\n          },\n          (direction: FlipDirection) => {\n            const currentVisiblePageIndices: [number] | [number, number] =\n              direction == FlipDirection.Forward\n                ? pageIndex + 2 === this.pagesCount\n                  ? [pageIndex + 1]\n                  : [pageIndex + 1, pageIndex + 2]\n                : pageIndex === 0\n                  ? [pageIndex]\n                  : [pageIndex - 1, pageIndex]\n            if (\n              this.prevVisiblePageIndices &&\n              this.prevVisiblePageIndices.length ===\n                currentVisiblePageIndices.length &&\n              currentVisiblePageIndices.every(\n                (v, i) => v === this.prevVisiblePageIndices![i]\n              )\n            ) {\n              return\n            }\n            const prevVisiblePageIndices = this.prevVisiblePageIndices\n            this.prevVisiblePageIndices = currentVisiblePageIndices\n\n            // TODO expose to outside using https://github.com/open-draft/strict-event-emitter, and just be a consumer internally\n            this.onTurned(currentVisiblePageIndices, prevVisiblePageIndices)\n          }\n        )\n      } else {\n        pageElement.style.transform = `scaleX(-1)translateX(${\n          this.isLTR ? `-` : ``\n        }100%)`\n        this.leaves[leafIndex].pages[1] = pageElement\n      }\n    })\n    const hammer = new Hammer(this.bookElement)\n    hammer.on('panstart', this.onDragStart.bind(this))\n    hammer.on('panmove', this.onDragUpdate.bind(this))\n    hammer.on('panend', this.onDragEnd.bind(this))\n    this.bookElement.addEventListener(\n      'touchstart',\n      this.handleTouchStart.bind(this),\n      { passive: false }\n    )\n    this.bookElement.addEventListener(\n      'touchmove',\n      this.handleTouchMove.bind(this),\n      { passive: false }\n    )\n    if (debug) this.fillDebugBar()\n  }\n  private fillDebugBar() {\n    const debugBar = document.createElement('div')\n    debugBar.className = 'flipbook-debug-bar'\n    this.bookElement?.appendChild(debugBar)\n    setInterval(() => {\n      // Populate debug bar with relevant information\n      debugBar.innerHTML = `\n          <div>Direction: ${this.isLTR ? 'LTR' : 'RTL'}</div>\n          <div>Current Leaf: ${\n            this.currentLeaf ? this.currentLeaf.index : 'None'\n          }</div>\n          <div>Flip dir: ${this.flipDirection}</div>\n          <div>Flip Î”: ${this.flipDelta}</div>\n          <div>Current Leaf Flip Position: ${this.currentLeaf?.flipPosition.toFixed(\n            3\n          )}</div>\n          <div>Is During Auto Flip: ${this.isDuringAutoFlip}</div>\n        `\n    }, 10)\n  }\n\n  private onDragStart(event: HammerInput) {\n    console.log('drag start')\n    if (this.currentLeaf || this.isDuringAutoFlip) {\n      this.flipDirection = FlipDirection.None\n      this.flipStartingPos = 0\n      return\n    }\n    this.flipStartingPos = event.center.x\n  }\n\n  private onDragUpdate(event: HammerInput) {\n    console.log('drag update')\n    if (this.isDuringAutoFlip || this.isDuringManualFlip) {\n      return\n    }\n    this.isDuringManualFlip = true\n    try {\n      const currentPos = event.center.x\n\n      this.flipDelta = this.isLTR\n        ? this.flipStartingPos - currentPos\n        : currentPos - this.flipStartingPos\n      const bookWidth = this.bookElement?.clientWidth ?? 0\n      if (Math.abs(this.flipDelta) > bookWidth) return\n      if (this.flipDelta === 0) return\n      this.flipDirection =\n        this.flipDirection !== FlipDirection.None\n          ? this.flipDirection\n          : this.flipDelta > 0\n            ? FlipDirection.Forward\n            : FlipDirection.Backward\n      switch (this.flipDirection) {\n        case FlipDirection.Forward: {\n          const posForward = (this.flipDelta / bookWidth) as FlipPosition\n          if (posForward > 1 || this.flipDelta < 0) {\n            return\n          }\n          if (!this.currentLeaf) {\n            if (this.isClosedInverted) {\n              return\n            } else {\n              this.currentLeaf = this.currentOrTurningLeaves[1]!\n            }\n          }\n          this.currentLeaf.efficientFlipToPosition(posForward)\n          break\n        }\n        case FlipDirection.Backward: {\n          const posBackward = (1 -\n            Math.abs(this.flipDelta) / bookWidth) as FlipPosition\n          if (posBackward < 0 || this.flipDelta > 0) {\n            return\n          }\n          if (!this.currentLeaf) {\n            if (this.isClosed) {\n              return\n            } else {\n              this.currentLeaf = this.currentOrTurningLeaves[0]\n            }\n          }\n          this.currentLeaf!.efficientFlipToPosition(posBackward)\n          break\n        }\n      }\n    } finally {\n      this.isDuringManualFlip = false\n    }\n  }\n\n  private async onDragEnd(event: HammerInput) {\n    console.log('drag end')\n    if (!this.currentLeaf || this.isDuringAutoFlip) {\n      this.flipDirection = FlipDirection.None\n      this.flipStartingPos = 0\n      return\n    }\n    const ppsX = event.velocityX * 1000 // pixels per second\n    let flipTo: FlipPosition\n    switch (this.flipDirection) {\n      case FlipDirection.Forward:\n        if (\n          (this.isLTR ? ppsX < -FAST_DELTA : ppsX > FAST_DELTA) ||\n          this.currentLeaf.flipPosition >= 0.5\n        ) {\n          flipTo = 1\n        } else {\n          flipTo = 0\n        }\n        break\n      case FlipDirection.Backward:\n        if (\n          (this.isLTR ? ppsX > FAST_DELTA : ppsX < -FAST_DELTA) ||\n          this.currentLeaf.flipPosition <= 0.5\n        ) {\n          flipTo = 0\n        } else {\n          flipTo = 1\n        }\n        break\n      default:\n        return\n    }\n\n    this.isDuringAutoFlip = true\n    this.flipDirection = FlipDirection.None\n    this.flipStartingPos = 0\n    await this.currentLeaf.flipToPosition(flipTo)\n    this.isDuringAutoFlip = false\n    this.currentLeaf = undefined\n  }\n\n  private handleTouchStart = (e: TouchEvent) => {\n    if (e.touches.length > 1) {\n      return\n    }\n    const touch = e.touches[0]\n    this.touchStartingPos = { x: touch.pageX, y: touch.pageY }\n  }\n\n  private handleTouchMove = (e: TouchEvent) => {\n    if (e.touches.length > 1) {\n      return\n    }\n    const touch = e.touches[0]\n    const deltaX = touch.pageX - this.touchStartingPos.x\n    const deltaY = touch.pageY - this.touchStartingPos.y\n    // only allow vertical scrolling, as if allowing horizontal scrolling, it will interfere with the flip gesture (for touch devices)\n    // TODO: allow horizontal scrolling if the user is not trying to flip, say if is scrolling an overflowed element\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n      e.preventDefault()\n    }\n  }\n  private onTurned(\n    currentVisiblePageIndices: [number] | [number, number],\n    prevVisibilePageIndices?: [number] | [number, number]\n  ) {\n    for (let i = 0; i < this.pageElements.length; i++) {\n      const pageElement = this.pageElements[i]\n      const action = currentVisiblePageIndices.includes(i)\n        ? pageElement.classList.add\n        : !prevVisibilePageIndices || !prevVisibilePageIndices.includes\n          ? () => null\n          : pageElement.classList.remove\n      action.bind(pageElement.classList)('current-page')\n    }\n    // TODO expose to outside using https://github.com/open-draft/strict-event-emitter, and just be a consumer internally.\n    // TODO: set prev-page / next-page classes for prev/next pages as accordingally\n  }\n  jumpToPage(pageIndex: number) {\n    // TODO: drop as probably totally replaced ith onTurned. maybe change onTurned name to onPageChanged.\n    if (this.onPageChanged) {\n      this.onPageChanged(pageIndex)\n    }\n  }\n}\n\nexport { FlipBook, PageSemantics }\n"],"names":["FlipDirection","NOT_FLIPPED","Leaf","index","pages","isFlipped","bookProperties","onTurned","value","flipPosition","velocity","resolve","currentFlipPosition","duration","start","step","timestamp","elapsed","progress","newPosition","page","isLTR","isOdd","rotateY","translateX","scaleX","throttle","AspectRatioImpl","width","height","aspectRatio","Size","rhsAspectRatio","rhsAspectRatioValue","FAST_DELTA","FlipBook","secondLeafIndex","leaf","options","selector","debug","bookElement","pageElements","leavesCount","coverSize","leafSize","pageElement","pageIndex","leafIndex","isOddPage","direction","currentVisiblePageIndices","v","i","prevVisiblePageIndices","hammer","Hammer","debugBar","event","currentPos","bookWidth","posForward","posBackward","ppsX","flipTo","e","touch","deltaX","deltaY","prevVisibilePageIndices"],"mappings":"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"}